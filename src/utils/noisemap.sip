/* ========
    Content from "noiseutils.h":355-703
======== */

class NoiseMap {
%Docstring "deindented"
    Implements a noise map, a two-dimensional array of floating-point
    values.

    A noise map is designed to store coherent-noise values generated by a
    noise module, although it can store values from any source. A noise
    map is often used as a terrain height map or a grayscale texture.

    The :py:attr:`size` (width & height) of the noise map can be specified
    during object construction or at any other time.

    The :py:func:`get_value()` and :py:func:`set_value()` methods can be
    used to access individual values stored in the noise map.

    This class manages its own memory. If you copy a noise map object into
    another noise map object, the original contents of the noise map
    object will be freed.

    If you specify a new size for the noise map and the new size is
    smaller than the current size, the allocated memory will not be
    reallocated. Call :py:func:`reclaim_memory()` to reclaim the wasted
    memory.

    **Border Values**

    All of the values outside of the noise map are assumed to have a
    common value known as the *border value*.

    To set the border value, use the :py:attr:`border_value` property.

    The :py:func:`get_value()` method returns the border value if the
    specified value lies outside of the noise map.

    **Internal Noise Map Structure**

    Internally, the values are organized into horizontal rows called
    *slabs*. Slabs are ordered from bottom to top.

    Each slab contains a contiguous row of values in memory. The values
    in a slab are organized left to right.

    The offset between the starting points of any two adjacent slabs is
    called the *stride amount*. The stride amount is measured by the
    number of ``float`` values between these two starting points, not by
    the number of bytes. For efficiency reasons, the stride is often a
    multiple of the machine word size.

    .. note::

        You can get an idea of the memory allocation of a noise map by
        calling ``len()`` on it. This returns the number of floats
        currently in memory.
%End

    public:
        NoiseMap();
        NoiseMap(int width, int height);
        NoiseMap(const NoiseMap& rhs);

        ~NoiseMap ();

        void Clear (float value) /PyName=clear/ ;
        %Docstring "deindented"
            clear(value)

            Clears the noise map to a specified value.

            :param float value: The value that all positions within the noise map are cleared to.
        %End

        void ReclaimMem () /PyName=reclaim_memory/ ;
        %Docstring "deindented"
            reclaim_memory()

            Reallocates the noise map to recover wasted memory.

            The content of the noise map is unaffected.
        %End

        void TakeOwnership (NoiseMap& source) /PyName=take_ownership/ ;
        %Docstring "deindented"
            take_ownership(source)

            Takes ownership of the buffer within the source noise map.

            :param noisypy.utils.NoiseMap source: The source noise map.

            On exit, the source noise map object becomes empty.

            This method only moves the buffer pointer so this method is very
            quick.
        %End

        int __len__() const;
        %Docstring "deindented"
            __len__()

            Returns the amount of memory allocated for this noise map. That is,
            the number of float values allocated.
        %End
        %MethodCode
            Py_BEGIN_ALLOW_THREADS
            sipRes = sipCpp->GetMemUsed();
            Py_END_ALLOW_THREADS
        %End
        
        float GetBorderValue () const /PyName=_get_border_value/ ;
        void SetBorderValue (float borderValue) /PyName=_set_border_value/ ;

        %Property(name=border_value, get=_get_border_value, set=_set_border_value) {
            %Docstring "deindented"
                The value used for all positions outside of the noise map.

                :type: float
            %End
        };
        
        int GetStride () const /PyName=_get_stride/;

        %Property(name=stride, get=_get_stride) {
            %Docstring "deindented"
                The stride amount of the noise map.

                :type: int

                The *stride amount* is the offset between the starting points
                of any two adjacent slabs in a noise map. It is measured by the
                number of ``float`` values between these two points, not by the
                number of bytes.
            %End
        };

        SIP_PYTUPLE _get_size();
        %MethodCode
            Py_BEGIN_ALLOW_THREADS
            int size[2] = {sipCpp->GetHeight(), sipCpp->GetWidth()};
            sipRes = Py_BuildValue("ii", size[0], size[1]);
            Py_END_ALLOW_THREADS
        %End

        void _set_size(SIP_PYTUPLE);
        %MethodCode
            int size[2];
            
            Py_ssize_t dim_num = PyTuple_Size(a0);
            
            if(!dim_num) {
                if(!PyErr_Occurred()) {
                    PyErr_SetString(PyExc_TypeError, "You must supply at least one argument.");
                }
                sipIsErr = 1;
            }

            else if (dim_num == 2) {
                if (PyArg_ParseTuple(a0, "ii", &size[0], &size[1])) {
                    Py_BEGIN_ALLOW_THREADS
                    sipCpp->SetSize(size[0], size[1]);
                    Py_END_ALLOW_THREADS
                } else {
                    sipIsErr = 1;
                }
            }

            else {
                PyErr_SetString(PyExc_TypeError, "You must specify two dimensions.");
                sipIsErr = 1;
            }
        %End

        %Property(name=size, get=_get_size, set=_set_size) {
            %Docstring "deindented"
                The size for the noise map. Must be positive.

                :type: (int, int)

                After setting this property, the contents of the noise map are
                undefined: if the ``OUT_OF_MEMORY`` exception occurs, this
                noise map object becomes empty, and if the ``INVALID_PARAM``
                exception occurs, the noise map is unmodified.
            %End
        };

        float GetValue (int x, int y) const /PyName=get_value/ ;
        %Docstring "deindented"
            get_value(x, y)

            Returns a value from the specified position in the noise map.

            :param int x: The x coordinate of the position.
            :param int y: The y coordinate of the position.

            This method returns the border value if the coordinates exist
            outside of the noise map.
        %End

        void SetValue (int x, int y, float value) /PyName=set_value/ ;
        %Docstring "deindented"
            set_value(x, y, value)

            Sets a value at a specified position in the noise map.

            :param int x: The x coordinate of the position.
            :param int y: The y coordinate of the position.
            :param float value: The value to set at the given position.

            This method does nothing if the noise map object is empty or the
            position is outside the bounds of the noise map.
        %End
};

/* ========
    Content from "noiseutils.h":1340-1468
======== */

class NoiseMapBuilder /Abstract/ {
%Docstring "deindented"
    Abstract base class for a noise-map builder

    A builder class builds a noise map by filling it with coherent-noise
    values generated from the surface of a three-dimensional mathematical
    object.  Each builder class defines a specific three-dimensional
    surface, such as a cylinder, sphere, or plane.

    A builder class describes these input values using a coordinate system
    applicable for the mathematical object (e.g., a latitude/longitude
    coordinate system for the spherical noise-map builder.)  It then
    "flattens" these coordinates onto a plane so that it can write the
    coherent-noise values into a two-dimensional noise map.

    To build the noise map, perform the following steps:
    
    * Set the bounding coordinates with the :py:attr:`bounds` property.
    * Set the noise map size, in points, using the :py:attr:`size` property.
    * Pass a NoiseMap object to the :py:func:`set_noisemap()` method.
    * Pass a noise module to the :py:func:`set_module()` method.
    * Call the :py:func:`build()` method.

    For example:

    .. code-block:: python
        :linenos: 

        builder = noisypy.utils.PlanarNoiseMapBuilder()
        builder.bounds = (-1, 1, -1, 1)
        builder.size = (256, 256)
        my_noisemap = builder.build_with_source(my_module)
        # my_noisemap now contains values from my_module

    Note that the bounds not defined in the abstract base class; they are
    only defined in the derived classes. This is because each model uses
    a different coordinate system.
%End

    public:
        virtual void Build() = 0 /PyName=classic_build/;
        %Docstring "deindented"
            Builds the noise map in the same fashion as the original 
            ``noiseutils``. That is, using the noisemap reference passed
            to :py:func:`set_noisemap` and the module reference passed to
            :py:func:`set_module`.

            If this method is successful, the destination noise map contains
            the coherent-noise values from the noise module passed to the
            :py:func:`set_module()` method.
        %End

        NoiseMap * Build2() /PyName=build/ ;
        %Docstring "deindented"
            Returns a newly-filled noise map.

            :rtype: noisypy.utils.NoiseMap

            If this method is successful, the returned noise map contains
            the coherent-noise values from the noise module passed to the
            :py:func:`set_module()` method.
        %End
        %MethodCode
            Py_BEGIN_ALLOW_THREADS
            try {
                sipRes = new NoiseMap();
                sipCpp->SetDestNoiseMap(*sipRes);
                sipCpp->Build();
            } catch (...) {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
        %End

        NoiseMap * Build3(const Module & source_module) /PyName=build_with_source/ ;
        %Docstring "deindented"
            build_with_source(source_module)

            Returns a new noise map filled with values from the given source
            module.

            :param noisypy.modules.Module source_module: The source module.
            :rtype: noisypy.utils.NoiseMap
        %End
        %MethodCode
            Py_BEGIN_ALLOW_THREADS
            try {
                sipCpp->SetSourceModule(*a0);
                sipRes = new NoiseMap();
                sipCpp->SetDestNoiseMap(*sipRes);
                sipCpp->Build();
            } catch (...) {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            Py_END_ALLOW_THREADS
        %End

        void SetDestNoiseMap(NoiseMap& destNoiseMap) /PyName=set_noisemap/ ;
        %Docstring "deindented"
            set_noisemap(noisemap)

            Sets the destination noise map.

            :param noisypy.utils.NoiseMap noisemap: The destination noise map.

            The destination noise map will contain the coherent-noise values
            from this noise map after a successful call to the :py:func:`build()`
            method.
        
            The destination noise map must exist throughout the lifetime of
            this object unless another noise map replaces that noise map.
        %End

        void SetSourceModule(const Module& sourceModule) /PyName=set_module/ ;
        %Docstring "deindented"
            set_module(noise_module)

            Sets the source module.
            
            :param noisypy.modules.Module noise_module: The source module.
            
            This object fills in a noise map with the coherent-noise values
            from this source module.
            
            The source module must exist throughout the lifetime of this
            object unless another noise module replaces that noise module.
        %End

        SIP_PYTUPLE _get_size();
        %MethodCode
            Py_BEGIN_ALLOW_THREADS
            int size[2] = {(int) sipCpp->GetDestHeight(), (int) sipCpp->GetDestWidth()};
            sipRes = Py_BuildValue("ii", size[0], size[1]);
            Py_END_ALLOW_THREADS
        %End

        void _set_size(SIP_PYTUPLE);
        %MethodCode
            int size[2];
            
            Py_ssize_t dim_num = PyTuple_Size(a0);
            
            if(!dim_num) {
                if(!PyErr_Occurred()) {
                    PyErr_SetString(PyExc_TypeError, "You must supply at least one argument.");
                }
                sipIsErr = 1;
            }

            else if (dim_num == 2) {
                if (PyArg_ParseTuple(a0, "ii", &size[0], &size[1])) {
                    Py_BEGIN_ALLOW_THREADS
                    sipCpp->SetDestSize(size[0], size[1]);
                    Py_END_ALLOW_THREADS
                } else {
                    sipIsErr = 1;
                }
            }

            else {
                PyErr_SetString(PyExc_TypeError, "You must specify two dimensions.");
                sipIsErr = 1;
            }
        %End

        %Property(name=size, get=_get_size, set=_set_size) {
            %Docstring "deindented"
                The size of the destination noise map.

                :type: (int, int)
        
                This property does not change the size of the noise map itself until the
                :py:func:`build()` method is called.
            %End
        };
};

class NoiseMapBuilderPlane: public NoiseMapBuilder /PyName=PlanarNoiseMapBuilder/ {
%Docstring "deindented"
    Builds a planar noise map.

    :param noisypy.modules.Module source_module: The source module to generate noise with.
    :param bool seamless: Whether the noise map should be tilable. Defaults to ``False``.

    This class builds a noise map by filling it with coherent-noise values generated
    from the surface of a plane.

    This class describes these input values using (x, z) coordinates. Their y 
    coordinates are always ``0.0``.

    The application must provide the lower and upper x coordinate bounds of the noise
    map, in units, and the lower and upper z coordinate bounds of the noise map, in
    units.

    To make a tileable noise map with no seams at the edges, use the
    :py:attr:`seamless` property.
%End

    public:
        NoiseMapBuilderPlane();

        NoiseMapBuilderPlane(const Module & source_module, bool seamless = false) /NoDerived/ ;
        %MethodCode
            Py_BEGIN_ALLOW_THREADS
            try {
                sipCpp = new sipNoiseMapBuilderPlane();
            } catch (...) {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            sipCpp->SetSourceModule(*a0);
            sipCpp->EnableSeamless(a1);
            Py_END_ALLOW_THREADS
        %End

        virtual void Build() /PyName=classic_build/ ;
        %Docstring "deindented"
            Builds the noise map in the same fashion as the original 
            ``noiseutils``. That is, using the noisemap reference passed
            to :py:func:`set_noisemap` and the module reference passed to
            :py:func:`set_module`.

            If this method is successful, the destination noise map contains
            the coherent-noise values from the noise module passed to the
            :py:func:`set_module()` method.
        %End

        // NoiseMap * Build2() /PyName=build/ ;
        // %Docstring "deindented"
        //     Returns a newly-filled noise map.

        //     :rtype: noisypy.utils.NoiseMap

        //     If this method is successful, the returned noise map contains
        //     the coherent-noise values from the noise module passed to the
        //     :py:func:`set_module()` method.
        // %End
        // %MethodCode
        //     Py_BEGIN_ALLOW_THREADS
        //     try {
        //         sipRes = new NoiseMap();
        //         sipCpp->SetDestNoiseMap(*sipRes);
        //         sipCpp->Build();
        //     } catch (...) {
        //         Py_BLOCK_THREADS

        //         sipRaiseUnknownException();
        //         return NULL;
        //     }
        //     Py_END_ALLOW_THREADS
        // %End

        // NoiseMap * Build3(const Module & source_module) /PyName=build_with_source/ ;
        // %Docstring "deindented"
        //     build_with_source(source_module)

        //     Returns a new noise map filled with values from the given source
        //     module.

        //     :param noisypy.modules.Module source_module: The source module.
        //     :rtype: noisypy.utils.NoiseMap
        // %End
        // %MethodCode
        //     Py_BEGIN_ALLOW_THREADS
        //     try {
        //         sipCpp->SetSourceModule(*a0);
        //         sipRes = new NoiseMap();
        //         sipCpp->SetDestNoiseMap(*sipRes);
        //         sipCpp->Build();
        //     } catch (...) {
        //         Py_BLOCK_THREADS

        //         sipRaiseUnknownException();
        //         return NULL;
        //     }
        //     Py_END_ALLOW_THREADS
        // %End

        bool IsSeamlessEnabled() const /PyName=_is_seamless_enabled/ ;
        void EnableSeamless(bool enable) /PyName=_enable_seamless/ ;

        %Property(name=seamless, get=_is_seamless_enabled, set=_enable_seamless) {
            %Docstring "deindented"
                Enabling seamless tiling builds a noise map with no seams at the edges.
                This allows the noise map to be tileable.

                :type: bool
            %End
        };

        SIP_PYTUPLE _get_bounds();
        %MethodCode
            Py_BEGIN_ALLOW_THREADS
            double bounds[4] = {sipCpp->GetLowerXBound(), sipCpp->GetUpperXBound(), sipCpp->GetLowerZBound(), sipCpp->GetUpperZBound()};
            sipRes = Py_BuildValue("dddd", bounds[0], bounds[1], bounds[2], bounds[3]);
            Py_END_ALLOW_THREADS
        %End

        void _set_bounds(SIP_PYTUPLE);
        %MethodCode
            double bounds[4];
            
            Py_ssize_t dim_num = PyTuple_Size(a0);
            
            if(!dim_num) {
                if(!PyErr_Occurred()) {
                    PyErr_SetString(PyExc_TypeError, "You must supply at least one argument.");
                }
                sipIsErr = 1;
            }

            else if (dim_num == 4) {
                if (PyArg_ParseTuple(a0, "dddd", &bounds[0], &bounds[1], &bounds[2], &bounds[3])) {
                    Py_BEGIN_ALLOW_THREADS
                    sipCpp->SetBounds(bounds[0], bounds[1], bounds[2], bounds[3]);
                    Py_END_ALLOW_THREADS
                } else {
                    sipIsErr = 1;
                }
            }

            else {
                PyErr_SetString(PyExc_TypeError, "You must specify four bounds.");
                sipIsErr = 1;
            }
        %End

        %Property(name=bounds, get=_get_bounds, set=_set_bounds) {
            %Docstring "deindented"
                The boundaries of the planar noise map.

                :type: (float, float, float, float)
            %End
        };
};

/* ========
    Content from "noiseutils.h":1470-1584
======== */

class NoiseMapBuilderCylinder: public NoiseMapBuilder /PyName=CylindricalNoiseMapBuilder/ {
%Docstring "deindented"
    Builds a cylindrical noise map.

    :param noisypy.modules.Module source_module: The source module to generate noise with.

    This class builds a noise map by filling it with coherent-noise values
    generated from the surface of a cylinder.

    This class describes these input values using an (angle, height)
    coordinate system.  After generating the coherent-noise value from the
    input value, it then "flattens" these coordinates onto a plane so that
    it can write the values into a two-dimensional noise map.

    The cylinder model has a radius of ``1.0`` unit and has infinite height.
    The cylinder is oriented along the ``y`` axis.  Its center is at the
    origin.

    The ``x`` coordinate in the noise map represents the angle around the
    cylinder's ``y`` axis.  The ``y`` coordinate in the noise map represents
    the height above the ``x-z`` plane.

    The application must provide the lower and upper angle bounds of the
    noise map, in degrees, and the lower and upper height bounds of the
    noise map, in units. See the :py:attr:`bounds` property for details.
%End

    public:
        NoiseMapBuilderCylinder ();

        NoiseMapBuilderCylinder(const Module & source_module) /NoDerived/ ;
        %MethodCode
            Py_BEGIN_ALLOW_THREADS
            try {
                sipCpp = new sipNoiseMapBuilderCylinder();
            } catch (...) {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            sipCpp->SetSourceModule(*a0);
            Py_END_ALLOW_THREADS
        %End

        virtual void Build() /PyName=classic_build/ ;
        %Docstring "deindented"
            Builds the noise map in the same fashion as the original 
            ``noiseutils``. That is, using the noisemap reference passed
            to :py:func:`set_noisemap` and the module reference passed to
            :py:func:`set_module`.

            If this method is successful, the destination noise map contains
            the coherent-noise values from the noise module passed to the
            :py:func:`set_module()` method.
        %End

        SIP_PYTUPLE _get_bounds();
        %MethodCode
            Py_BEGIN_ALLOW_THREADS
            double bounds[4] = {sipCpp->GetLowerAngleBound(), sipCpp->GetUpperAngleBound(), sipCpp->GetLowerHeightBound(), sipCpp->GetUpperHeightBound()};
            sipRes = Py_BuildValue("dddd", bounds[0], bounds[1], bounds[2], bounds[3]);
            Py_END_ALLOW_THREADS
        %End

        void _set_bounds(SIP_PYTUPLE);
        %MethodCode
            double bounds[4];
            
            Py_ssize_t dim_num = PyTuple_Size(a0);
            
            if(!dim_num) {
                if(!PyErr_Occurred()) {
                    PyErr_SetString(PyExc_TypeError, "You must supply at least one argument.");
                }
                sipIsErr = 1;
            }

            else if (dim_num == 4) {
                if (PyArg_ParseTuple(a0, "dddd", &bounds[0], &bounds[1], &bounds[2], &bounds[3])) {
                    Py_BEGIN_ALLOW_THREADS
                    sipCpp->SetBounds(bounds[0], bounds[1], bounds[2], bounds[3]);
                    Py_END_ALLOW_THREADS
                } else {
                    sipIsErr = 1;
                }
            }

            else {
                PyErr_SetString(PyExc_TypeError, "You must specify four bounds.");
                sipIsErr = 1;
            }
        %End

        %Property(name=bounds, get=_get_bounds, set=_set_bounds) {
            %Docstring "deindented"
                The coordinate boundaries of the noise map.

                :type: (float, float, float, float)

                The order is as follows:

                * The lower angle boundary of the noise map, in degrees.
                * The upper angle boundary of the noise map, in degrees.
                * The lower height boundary of the noise, in units.
                * The upper height boundary of the noise, in units.

                One unit is equal to the radius of the cylinder.
            %End
        };
};

/* ========
    Content from "noiseutils.h":1715-1818
======== */

class NoiseMapBuilderSphere: public NoiseMapBuilder /PyName=SphericalNoiseMapBuilder/ {
%Docstring "deindented"
    Builds a spherical noise map.

    :param noisypy.modules.Module source_module: The source module to generate noise with.

    This class builds a noise map by filling it with coherent-noise values
    generated from the surface of a sphere.

    This class describes these input values using an (latitude, longitude)
    coordinate system. After generating the coherent-noise value from the
    input value, it then "flattens" these coordinates onto a plane so that
    it can write the values into a two-dimensional noise map.

    The cylinder model has a radius of ``1.0`` unit. Its center is at the
    origin.

    The ``x`` coordinate in the noise map represents the longitude. The ``y``
    coordinate in the noise map represents the latitude.

    The application must provide the southern, northern, western, and
    eastern bounds of the noise map, in degrees. See the :py:attr:`bounds`
    property for details.
%End

    public:
        NoiseMapBuilderSphere ();

        NoiseMapBuilderSphere(const Module & source_module) /NoDerived/ ;
        %MethodCode
            Py_BEGIN_ALLOW_THREADS
            try {
                sipCpp = new sipNoiseMapBuilderSphere();
            } catch (...) {
                Py_BLOCK_THREADS

                sipRaiseUnknownException();
                return NULL;
            }
            sipCpp->SetSourceModule(*a0);
            Py_END_ALLOW_THREADS
        %End

        virtual void Build() /PyName=classic_build/ ;
        %Docstring "deindented"
            Builds the noise map in the same fashion as the original 
            ``noiseutils``. That is, using the noisemap reference passed
            to :py:func:`set_noisemap` and the module reference passed to
            :py:func:`set_module`.

            If this method is successful, the destination noise map contains
            the coherent-noise values from the noise module passed to the
            :py:func:`set_module()` method.
        %End

        SIP_PYTUPLE _get_bounds();
        %MethodCode
            Py_BEGIN_ALLOW_THREADS
            double bounds[4] = {sipCpp->GetSouthLatBound(), sipCpp->GetNorthLatBound(), sipCpp->GetWestLonBound(), sipCpp->GetEastLonBound()};
            sipRes = Py_BuildValue("dddd", bounds[0], bounds[1], bounds[2], bounds[3]);
            Py_END_ALLOW_THREADS
        %End

        void _set_bounds(SIP_PYTUPLE);
        %MethodCode
            double bounds[4];
            
            Py_ssize_t dim_num = PyTuple_Size(a0);
            
            if(!dim_num) {
                if(!PyErr_Occurred()) {
                    PyErr_SetString(PyExc_TypeError, "You must supply at least one argument.");
                }
                sipIsErr = 1;
            }

            else if (dim_num == 4) {
                if (PyArg_ParseTuple(a0, "dddd", &bounds[0], &bounds[1], &bounds[2], &bounds[3])) {
                    Py_BEGIN_ALLOW_THREADS
                    sipCpp->SetBounds(bounds[0], bounds[1], bounds[2], bounds[3]);
                    Py_END_ALLOW_THREADS
                } else {
                    sipIsErr = 1;
                }
            }

            else {
                PyErr_SetString(PyExc_TypeError, "You must specify four bounds.");
                sipIsErr = 1;
            }
        %End

        %Property(name=bounds, get=_get_bounds, set=_set_bounds) {
            %Docstring "deindented"
                The coordinate boundaries of the noise map.

                :type: (float, float, float, float)

                The order is as follows:

                * The southern boundary of the noise map, in degrees.
                * The northern boundary of the noise map, in degrees.
                * The western boundary of the noise map, in degrees.
                * The eastern boundary of the noise map, in degrees.

            %End
        };
};
